#include <msp430.h>
#include <stdio.h>

#define GreenLED BIT6
#define RedLED   BIT0
#define BUTTON   BIT3

// ===== World layout params =====
#define W_SUM            10      // total obstacles per row (left + right)
#define F_SPACE          50      // fixed tunnel width
#define ROW_LEN        (W_SUM + F_SPACE)   // total columns per row

#define MIN_WALL          0
#define MAX_WALL_DELTA    1      // <= 1 space change per update

#define N_LINES          10      // number of rows rendered at once
#define USER_ROW_INDEX    3      // avatar always drawn on line 4 (0-based)

// ===== Game tick (effective 30 Hz via 60 Hz base) =====
#define GAME_HZ           30
volatile unsigned char tick60  = 0;  // toggles each ~60 Hz ISR
volatile unsigned char tickFlag = 0; // do 30 Hz work in main when set

// ===== Runtime flags/state =====
volatile char letter;
volatile char letterFlag = 0;
volatile char gameOver   = 0;

volatile char obtacle    = '*';
volatile char freeSpace  = ' ';
volatile char user       = 'u';

unsigned char r, i, c;

volatile unsigned char positionUser = (ROW_LEN + 1) / 2; // 1-based column
volatile unsigned char userRow      = USER_ROW_INDEX;     // fixed row for avatar

// Direction for held-key glide: -1 left, 0 stop, +1 right
volatile int dir = 0;

// Button debounce piggyback on tick
volatile unsigned char debounceCount = 0;
volatile unsigned char pendingResetCheck = 0;

// Precomputed layout: per-row wall splits (left + right == W_SUM)
static unsigned char leftArr[N_LINES];
static unsigned char rightArr[N_LINES];

// ===== UART helpers =====
static inline void tx(char ch) {
  while (!(IFG2 & UCA0TXIFG));
  UCA0TXBUF = ch;
}
static inline void tx_str(const char *s) { while (*s) tx(*s++); }
static inline void clear_screen(void) {
  tx(0x1B); tx('['); tx('2'); tx('J');   // ESC[2J clear screen
  tx(0x1B); tx('['); tx('H');            // ESC[H  cursor home
}

// ===== Tiny PRNG (16-bit LFSR) =====
static unsigned int rng = 0xACE1u;
static inline unsigned int lfsr16(void) {
  // taps 16,14,13,11 (poly 0xB400)
  unsigned int lsb = ((rng >> 0) ^ (rng >> 2) ^ (rng >> 3) ^ (rng >> 5)) & 1u;
  rng = (rng >> 1) | (lsb << 15);
  return rng;
}
static inline unsigned char urand_bounded(unsigned char max_inclusive) {
  unsigned int r = lfsr16();
  unsigned char hi = (unsigned char)(r >> 8);
  return (unsigned char)((hi * (unsigned int)(max_inclusive + 1)) >> 8);
}

// ===== Wall generation with bounded delta =====
static inline void pick_next_split_bounded_from(unsigned char prevLeft,
                                                unsigned char* outLeft,
                                                unsigned char* outRight)
{
  unsigned char minL = MIN_WALL;
  unsigned char maxL = (unsigned char)(W_SUM - MIN_WALL);

  if (prevLeft < minL) prevLeft = minL;
  if (prevLeft > maxL) prevLeft = maxL;

  // random step in [-MAX_WALL_DELTA, +MAX_WALL_DELTA]
  unsigned char idx = urand_bounded((unsigned char)(2 * MAX_WALL_DELTA)); // 0..2D
  int step   = (int)idx - (int)MAX_WALL_DELTA;                             // -D..+D
  int target = (int)prevLeft + step;

  if (target < (int)minL) target = (int)minL;
  if (target > (int)maxL) target = (int)maxL;

  *outLeft  = (unsigned char)target;
  *outRight = (unsigned char)(W_SUM - (unsigned char)target);
}

// Fill the whole layout using bounded steps starting from a seed
static inline void generate_layout(unsigned char seedLeft) {
  unsigned char L = seedLeft, R = (unsigned char)(W_SUM - seedLeft);
  for (i = 0; i < N_LINES; ++i) {
    pick_next_split_bounded_from(L, &L, &R);
    leftArr[i]  = L;
    rightArr[i] = R;
  }
}

// Scroll: drop row 0, shift up, append a new random row at bottom
static inline void advance_layout_one_row(void) {
  for (i = 0; i < N_LINES - 1; ++i) {
    leftArr[i]  = leftArr[i + 1];
    rightArr[i] = rightArr[i + 1];
  }
  // Generate new bottom row from previous bottom as reference
  unsigned char newL, newR;
  pick_next_split_bounded_from(leftArr[N_LINES - 2], &newL, &newR);
  leftArr[N_LINES - 1]  = newL;
  rightArr[N_LINES - 1] = newR;
}

// ===== Rendering =====
static inline void render_row(unsigned char leftCount,
                              unsigned char rightCount,
                              unsigned char drawUserHere)
{
  unsigned char absPos = 0;

  // left wall
  for (c = 0; c < leftCount; ++c) {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx('A'); gameOver = 1; }
    else                                                     { tx(obtacle); }
  }

  // tunnel
  for (c = 0; c < F_SPACE; ++c) {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx(user); }
    else                                                     { tx(freeSpace); }
  }

  // right wall
  for (c = 0; c < rightCount; ++c) {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx('A'); gameOver = 1; }
    else                                                     { tx(obtacle); }
  }

  tx('\r'); tx('\n');
}

static inline void render_all(unsigned char showUser) {
  clear_screen();
  for (r = 0; r < N_LINES; ++r) {
    render_row(leftArr[r], rightArr[r], (showUser && (r == userRow)));
  }
}

// ===== Game reset =====
static inline void reset_game(void) {
  gameOver     = 0;
  positionUser = (ROW_LEN + 1) / 2;
  userRow      = USER_ROW_INDEX;
  dir          = 0;

  rng ^= 0x9E37u;                    // stir seed a bit
  unsigned char seedLeft = W_SUM / 2;
  generate_layout(seedLeft);
  render_all(1);
}

// ===== Main =====
void main(void)
{
  WDTCTL = WDTPW | WDTHOLD;        // stop watchdog

  // --- Clock: DCO @ 16 MHz ---
  BCSCTL1 = CALBC1_16MHZ;
  DCOCTL  = CALDCO_16MHZ;
  // MCLK = SMCLK = ~16 MHz (default dividers)

  // LEDs
  P1DIR |= GreenLED | RedLED;
  P1OUT &= ~(GreenLED | RedLED);

  // UART pins (P1.1 RXD, P1.2 TXD)
  P1SEL  |= BIT1 | BIT2;
  P1SEL2 |= BIT1 | BIT2;

  // Button (reset)
  P1DIR &= ~BUTTON;
  P1REN |= BUTTON;
  P1OUT |= BUTTON;      // pull-up
  P1IES |= BUTTON;      // high->low
  P1IFG &= ~BUTTON;
  P1IE  |= BUTTON;

  // --- UART USCI_A0 @ 460800 bps, SMCLK=16 MHz, oversampling ---
  // Math: 16e6/(16*460800)=2.1701 → UCBR=2, frac=0.1701 → UCBRF≈2, UCBRS=0
  UCA0CTL1 |= UCSWRST | UCSSEL_2;       // hold in reset, SMCLK
  UCA0BR0 = 2;                          // UCBR
  UCA0BR1 = 0;
  UCA0MCTL = (UCBRF_2) | (UCBRS_0) | UCOS16;
  UCA0CTL1 &= ~UCSWRST;
  IE2 |= UCA0RXIE;

  // If your USB-UART can't do 460800, comment the block above and use 230400:
  /*
  UCA0CTL1 |= UCSWRST | UCSSEL_2;
  UCA0BR0 = 4;                          // 16e6/(16*230400)=4.340 → UCBR=4
  UCA0BR1 = 0;
  UCA0MCTL = (UCBRF_5) | (UCBRS_0) | UCOS16; // frac≈0.340 → UCBRF=5
  UCA0CTL1 &= ~UCSWRST;
  IE2 |= UCA0RXIE;
  */

  // --- TimerA0: base ~60 Hz; fold to 30 Hz in ISR ---
  // SMCLK/8 = 2 MHz; CCR0=33333 → ~60 Hz (2e6 / 33333 ≈ 60)
  TA0CCR0  = 33333;
  TA0CCTL0 = CCIE;
  TA0CTL   = TASSEL_2 | ID_3 | MC_1;    // SMCLK, /8, up mode

  _enable_interrupt();

  // Build initial layout and draw
  reset_game();

  // Main loop: input, held-key glide, and timed auto-scroll
  while (1)
  {
    // Consume any received byte (non-blocking)
    if (letterFlag) {
      char l = letter;
      letterFlag = 0;

      if (!gameOver) {
        if (l == 'a')      dir = -1;
        else if (l == 'd') dir = +1;
        else if (l == ' ') dir =  0;   // optional stop
      }
    }

    // 30 Hz game tick
    if (tickFlag && !gameOver) {
      tickFlag = 0;

      // Held-key glide (one column per tick)
      if (dir < 0 && positionUser > 1) positionUser--;
      else if (dir > 0 && positionUser < ROW_LEN) positionUser++;

      // Advance world one row and redraw with user on fixed row 4
      advance_layout_one_row();
      render_all(1);
    }

    // Debounce gate after delay
    if (pendingResetCheck && debounceCount == 0) {
      pendingResetCheck = 0;
      if (!(P1IN & BUTTON)) { // still pressed -> reset
        reset_game();
      }
      // Re-enable button IRQ
      P1IFG &= ~BUTTON;
      P1IE  |= BUTTON;
    }

    __no_operation();
  }
}

// ===== ISRs =====

// UART RX ISR: capture byte
#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX__ISR(void)
{
  letter = UCA0RXBUF;
  letterFlag = 1;
}

// TimerA0 CCR0 ISR: ~60 Hz heartbeat → fold to 30 Hz
#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR (void)
{
  tick60 ^= 1;
  if (tick60) tickFlag = 1;  // every other ISR → ~30 Hz

  // If a debounce is running, count down here (~16.7 ms per 60 Hz tick)
  if (debounceCount > 0) {
    debounceCount--;
  }
}

// Port 1 ISR: start debounce window for reset button
#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{
  // Start ~6 ticks (~100 ms @ 60 Hz) debounce; disable further button IRQs
  debounceCount = 6;
  pendingResetCheck = 1;
  P1IE  &= ~BUTTON;
  P1IFG &= ~BUTTON;
}
