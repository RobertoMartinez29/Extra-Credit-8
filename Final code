#include <msp430.h>
#include <stdio.h>
#include <math.h>

#define GreenLED BIT6
#define RedLED   BIT0
#define BUTTON   BIT3

#define W_SUM            10
#define F_SPACE          15
#define ROW_LEN        (W_SUM + F_SPACE)

#define MIN_WALL          0
#define MAX_WALL_DELTA    1

#define N_LINES          10
#define USER_ROW_INDEX    3

#define GAME_HZ           30
volatile unsigned char tick60  = 0;
volatile unsigned char tickFlag = 0;

volatile char gameOver   = 0;

volatile char obtacle    = '*';
volatile char freeSpace  = ' ';
volatile char user       = 'u';

unsigned char r, i, c;

volatile unsigned char positionUser = (ROW_LEN + 1) / 2;
volatile unsigned char userRow      = USER_ROW_INDEX;

volatile int dir = 0;

volatile unsigned char debounceCount = 0;
volatile unsigned char pendingResetCheck = 0;

static unsigned char leftArr[N_LINES];
static unsigned char rightArr[N_LINES];

static inline void tx(char ch) {
  while (!(IFG2 & UCA0TXIFG));
  UCA0TXBUF = ch;
}
static inline void tx_str(const char *s) { while (*s) tx(*s++); }
static inline void clear_screen(void) 
{
  tx(0x1B); tx('['); tx('2'); tx('J');
  tx(0x1B); tx('['); tx('H');
}

static unsigned int rng = 0xACE1u;
static inline unsigned int lfsr16(void) 
{
  unsigned int lsb = ((rng >> 0) ^ (rng >> 2) ^ (rng >> 3) ^ (rng >> 5)) & 1u;
  rng = (rng >> 1) | (lsb << 15);
  return rng;
}
static inline unsigned char urand_bounded(unsigned char max_inclusive) 
{
  unsigned int r = lfsr16();
  unsigned char hi = (unsigned char)(r >> 8);
  return (unsigned char)((hi * (unsigned int)(max_inclusive + 1)) >> 8);
}

static inline void pick_next_split_bounded_from(unsigned char prevLeft,
                                                unsigned char* outLeft,
                                                unsigned char* outRight)
{
  unsigned char minL = MIN_WALL;
  unsigned char maxL = (unsigned char)(W_SUM - MIN_WALL);

  if (prevLeft < minL) prevLeft = minL;
  if (prevLeft > maxL) prevLeft = maxL;

  unsigned char idx = urand_bounded((unsigned char)(2 * MAX_WALL_DELTA));
  int step   = (int)idx - (int)MAX_WALL_DELTA;
  int target = (int)prevLeft + step;

  if (target < (int)minL) target = (int)minL;
  if (target > (int)maxL) target = (int)maxL;

  *outLeft  = (unsigned char)target;
  *outRight = (unsigned char)(W_SUM - (unsigned char)target);
}

static inline void generate_layout(unsigned char seedLeft) 
{
  unsigned char L = seedLeft, R = (unsigned char)(W_SUM - seedLeft);
  for (i = 0; i < N_LINES; ++i) {
    pick_next_split_bounded_from(L, &L, &R);
    leftArr[i]  = L;
    rightArr[i] = R;
  }
}

static inline void advance_layout_one_row(void) 
{
  for (i = 0; i < N_LINES - 1; ++i) {
    leftArr[i]  = leftArr[i + 1];
    rightArr[i] = rightArr[i + 1];
  }
  unsigned char newL, newR;
  pick_next_split_bounded_from(leftArr[N_LINES - 2], &newL, &newR);
  leftArr[N_LINES - 1]  = newL;
  rightArr[N_LINES - 1] = newR;
}

static inline void render_row(unsigned char leftCount,
                              unsigned char rightCount,
                              unsigned char drawUserHere)
{
  unsigned char absPos = 0;

  for (c = 0; c < leftCount; ++c) 
  {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx('A'); gameOver = 1; }
    else                                                     { tx(obtacle); }
  }

  for (c = 0; c < F_SPACE; ++c) 
  {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx(user); }
    else                                                     { tx(freeSpace); }
  }

  for (c = 0; c < rightCount; ++c) 
  {
    absPos++;
    if (!gameOver && drawUserHere && absPos == positionUser) { tx('A'); gameOver = 1; }
    else                                                     { tx(obtacle); }
  }

  tx('\r'); tx('\n');
}

static inline void render_all(unsigned char showUser) 
{
  clear_screen();
  for (r = 0; r < N_LINES; ++r) 
  {
    render_row(leftArr[r], rightArr[r], (showUser && (r == userRow)));
  }
}

static inline void reset_game(void) 
{
  gameOver     = 0;
  positionUser = (ROW_LEN + 1) / 2;
  userRow      = USER_ROW_INDEX;
  dir          = 0;

  rng ^= 0x9E37u;
  unsigned char seedLeft = W_SUM / 2;
  generate_layout(seedLeft);
  render_all(1);
}

#define USE_CLOCK
#define USE_I2C_USCI
#define USE_MPU6050
#define USE_UART

#include <wchar.h>
#include "Library/mymath.h"
#include "msp430g2553.h"
#include "Library/Global.h"
#include "Library/Clock.h"
#include "Library/I2C_USCI.h"
#include "Library/MPU6050.h"

#define RAD2DEG(x) ((x) * 57.2957795f)

volatile unsigned char toLeft  = 0;
volatile unsigned char toRight = 0;

static inline float compute_roll_deg(void) 
{
  float ay = (float)ACCEL_YOUT;
  float az = (float)ACCEL_ZOUT;
  return RAD2DEG(atan2f(ay, az));
}

void main(void)
{
  WDTCTL = WDTPW | WDTHOLD;

  BCSCTL1 = CALBC1_16MHZ;
  DCOCTL  = CALDCO_16MHZ;

  P1DIR |= GreenLED | RedLED;
  P1OUT &= ~(GreenLED | RedLED);

  P1SEL  |= BIT1 | BIT2;
  P1SEL2 |= BIT1 | BIT2;

  P1DIR &= ~BUTTON;
  P1REN |= BUTTON;
  P1OUT |= BUTTON;
  P1IES |= BUTTON;
  P1IFG &= ~BUTTON;
  P1IE  |= BUTTON;

  UCA0CTL1 |= UCSWRST | UCSSEL_2;
  UCA0BR0 = 2;
  UCA0BR1 = 0;
  UCA0MCTL = (UCBRF_2) | (UCBRS_0) | UCOS16;
  UCA0CTL1 &= ~UCSWRST;

  Init_I2C_USCI(MPU6050_ADDRESS);
  Setup_MPU6050();
  __delay_cycles(320000);

  Get_Accel_Values();
  ACCEL_XOUT = ACCEL_YOUT = ACCEL_ZOUT = 0;
  ACCEL_XOUT_PAST = ACCEL_YOUT_PAST = ACCEL_ZOUT_PAST = 0;
  ACCEL_XA = ACCEL_YA = ACCEL_ZA = 0;
  ACCEL_XV = ACCEL_YV = ACCEL_ZV = 0;
  ACCEL_XDECAC = ACCEL_YDECAC = ACCEL_ZDECAC = 0;

  TA0CCR0  = 33333;
  TA0CCTL0 = CCIE;
  TA0CTL   = TASSEL_2 | ID_3 | MC_1;

  __enable_interrupt();

  reset_game();

  while (1)
  {
    Get_Accel_Values();
    float roll_deg = compute_roll_deg();

    toLeft  = (roll_deg <= -90.0f) ? 1 : 0;
    toRight = (roll_deg >= +90.0f) ? 1 : 0;

    if (!gameOver) {
      if (toLeft)       dir = -1;
      else if (toRight) dir = +1;
      else              dir =  0;
    } else {
      dir = 0;
    }

    if (tickFlag && !gameOver) {
      tickFlag = 0;

      if (dir < 0 && positionUser > 1) positionUser--;
      else if (dir > 0 && positionUser < ROW_LEN) positionUser++;

      advance_layout_one_row();
      render_all(1);
    }

    if (pendingResetCheck && debounceCount == 0) {
      pendingResetCheck = 0;
      if (!(P1IN & BUTTON)) {
        reset_game();
      }
      P1IFG &= ~BUTTON;
      P1IE  |= BUTTON;
    }

    __no_operation();
  }
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR (void)
{
  tick60 ^= 1;
  if (tick60) tickFlag = 1;

  if (debounceCount > 0) {
    debounceCount--;
  }
}

#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{
  debounceCount = 6;
  pendingResetCheck = 1;
  P1IE  &= ~BUTTON;
  P1IFG &= ~BUTTON;
}
